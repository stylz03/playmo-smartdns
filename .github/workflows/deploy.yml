name: Deploy SmartDNS

on:
  push:
    branches:
      - main
    # paths: removed to trigger on all changes to main branch
  workflow_dispatch:   # allow manual runs
  schedule:
    - cron: "0 7 * * *"   # run daily at 07:00 UTC for auto re-validation

jobs:
  terraform:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::843336589038:role/playmo-terraform-deploy
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: terraform init
        working-directory: terraform

      - name: Terraform Validate
        run: terraform validate
        working-directory: terraform
        env:
          # Provide default values for variables during validation
          TF_VAR_use_existing_eip: "false"
          TF_VAR_existing_eip_address: "3.151.46.11"

      - name: Import existing resources if they exist
        run: |
          # Get default VPC ID
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text --region us-east-2)
          echo "Default VPC ID: $VPC_ID"
          
          # Import Security Group if it exists
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=playmo-smartdns-dns-only-sg" "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[0].GroupId' --output text --region us-east-2 2>/dev/null || echo "")
          
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ] && [ "$SG_ID" != "" ]; then
            echo "Found existing security group: $SG_ID"
            terraform import aws_security_group.smartdns_sg $SG_ID || echo "Security group already in state or import failed"
          else
            echo "No existing security group found, will create new one"
          fi
          
          # Import IAM Role if it exists (IAM is global, no region needed)
          ROLE_NAME="playmo-smartdns-dns-only-lambda-role"
          if aws iam get-role --role-name $ROLE_NAME >/dev/null 2>&1; then
            echo "Found existing IAM role: $ROLE_NAME"
            # Check if already in state
            if terraform state show 'aws_iam_role.lambda_role[0]' >/dev/null 2>&1; then
              echo "IAM role already in Terraform state"
            else
              echo "Importing IAM role into Terraform state..."
              terraform import 'aws_iam_role.lambda_role[0]' $ROLE_NAME 2>&1 || echo "IAM role import failed"
            fi
          else
            echo "No existing IAM role found, will create new one"
          fi
          
          # Import IAM Policy if it exists
          POLICY_NAME="playmo-smartdns-dns-only-lambda-sg-policy"
          # Try multiple methods to get the policy ARN
          POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='$POLICY_NAME'].Arn" --output text 2>/dev/null | tr '\t' '\n' | head -n1 || echo "")
          
          # Alternative: get by account and policy name pattern
          if [ -z "$POLICY_ARN" ] || [ "$POLICY_ARN" == "None" ]; then
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo "843336589038")
            POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${POLICY_NAME}"
            # Verify it exists
            if ! aws iam get-policy --policy-arn "$POLICY_ARN" >/dev/null 2>&1; then
              POLICY_ARN=""
            fi
          fi
          
          if [ -n "$POLICY_ARN" ] && [ "$POLICY_ARN" != "None" ] && [ "$POLICY_ARN" != "" ]; then
            echo "Found existing IAM policy: $POLICY_ARN"
            # Check if already in state
            if terraform state show 'aws_iam_policy.lambda_sg_policy[0]' >/dev/null 2>&1; then
              echo "IAM policy already in Terraform state"
            else
              echo "Importing IAM policy into Terraform state..."
              if terraform import 'aws_iam_policy.lambda_sg_policy[0]' "$POLICY_ARN" 2>&1; then
                echo "‚úÖ Successfully imported IAM policy"
              else
                echo "‚ö†Ô∏è IAM policy import failed, but continuing..."
              fi
            fi
            
            # Also import the policy attachment if role exists
            if aws iam get-role --role-name $ROLE_NAME >/dev/null 2>&1; then
              if terraform state show 'aws_iam_role_policy_attachment.attach_lambda_policy[0]' >/dev/null 2>&1; then
                echo "Policy attachment already in Terraform state"
              else
                echo "Importing policy attachment..."
                if terraform import 'aws_iam_role_policy_attachment.attach_lambda_policy[0]' "$ROLE_NAME/$POLICY_ARN" 2>&1; then
                  echo "‚úÖ Successfully imported policy attachment"
                else
                  echo "‚ö†Ô∏è Policy attachment import failed, but continuing..."
                fi
              fi
            fi
          else
            echo "No existing IAM policy found, will create new one"
          fi
          
          # Import Lambda Function if it exists
          LAMBDA_FUNCTION_NAME="playmo-smartdns-dns-only-whitelist"
          if aws lambda get-function --function-name $LAMBDA_FUNCTION_NAME --region us-east-2 >/dev/null 2>&1; then
            echo "Found existing Lambda function: $LAMBDA_FUNCTION_NAME"
            if terraform state show 'aws_lambda_function.whitelist' >/dev/null 2>&1; then
              echo "Lambda function already in Terraform state"
            else
              echo "Importing Lambda function into Terraform state..."
              if terraform import 'aws_lambda_function.whitelist' $LAMBDA_FUNCTION_NAME 2>&1; then
                echo "‚úÖ Successfully imported Lambda function"
                
                # Also import Lambda function URL if it exists
                if terraform state show 'aws_lambda_function_url.whitelist' >/dev/null 2>&1; then
                  echo "Lambda function URL already in Terraform state"
                else
                  echo "Importing Lambda function URL..."
                  # Lambda function URL import uses the function name
                  terraform import 'aws_lambda_function_url.whitelist' $LAMBDA_FUNCTION_NAME 2>&1 || echo "Lambda function URL import failed (may not exist yet)"
                fi
                
                # Also import Lambda permission if it exists
                if terraform state show 'aws_lambda_permission.allow_public_url' >/dev/null 2>&1; then
                  echo "Lambda permission already in Terraform state"
                else
                  echo "Importing Lambda permission..."
                  # Lambda permission import format: function_name/statement_id
                  terraform import 'aws_lambda_permission.allow_public_url' "$LAMBDA_FUNCTION_NAME/AllowPublicFunctionUrlInvoke" 2>&1 || echo "Lambda permission import failed (may not exist yet)"
                fi
              else
                echo "‚ö†Ô∏è Lambda function import failed, but continuing..."
              fi
            fi
          else
            echo "No existing Lambda function found, will create new one"
          fi
          
          # Import EC2 Instance if it exists (get the most recent running instance with the correct name)
          INSTANCE_NAME="playmo-smartdns-dns-only-ec2"
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" \
            --query 'Reservations[*].Instances[*].[InstanceId,LaunchTime]' \
            --output text --region us-east-2 2>/dev/null | \
            sort -k2 -r | head -n1 | awk '{print $1}' || echo "")
          
          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ] && [ "$INSTANCE_ID" != "" ]; then
            echo "Found existing EC2 instance: $INSTANCE_ID"
            if terraform state show 'aws_instance.smartdns' >/dev/null 2>&1; then
              echo "EC2 instance already in Terraform state"
            else
              echo "Importing EC2 instance into Terraform state..."
              if terraform import 'aws_instance.smartdns' $INSTANCE_ID 2>&1; then
                echo "‚úÖ Successfully imported EC2 instance"
                
                # Check if instance has an Elastic IP and import it
                EIP_ALLOCATION=$(aws ec2 describe-addresses \
                  --filters "Name=instance-id,Values=$INSTANCE_ID" \
                  --query 'Addresses[0].AllocationId' \
                  --output text --region us-east-2 2>/dev/null || echo "")
                
                if [ -n "$EIP_ALLOCATION" ] && [ "$EIP_ALLOCATION" != "None" ] && [ "$EIP_ALLOCATION" != "" ]; then
                  echo "Found Elastic IP: $EIP_ALLOCATION"
                  if terraform state show 'aws_eip.smartdns' >/dev/null 2>&1; then
                    echo "Elastic IP already in Terraform state"
                  else
                    echo "Importing Elastic IP..."
                    terraform import 'aws_eip.smartdns' $EIP_ALLOCATION 2>&1 || echo "Elastic IP import failed"
                  fi
                fi
              else
                echo "‚ö†Ô∏è EC2 instance import failed, but continuing..."
              fi
            fi
          else
            echo "No existing EC2 instance found, will create new one"
          fi
        working-directory: terraform
        continue-on-error: true

      - name: Clean up unused Elastic IPs
        run: |
          echo "Checking for unused Elastic IPs in us-east-2..."
          # Get all unassociated EIPs
          UNUSED_EIPS=$(aws ec2 describe-addresses \
            --region us-east-2 \
            --filters "Name=domain,Values=vpc" \
            --query 'Addresses[?AssociationId==`null`].[AllocationId,PublicIp]' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$UNUSED_EIPS" ]; then
            echo "$UNUSED_EIPS" | while read ALLOC_ID EIP_IP; do
              if [ -n "$ALLOC_ID" ] && [ "$ALLOC_ID" != "None" ]; then
                echo "Found unused EIP: $EIP_IP (Allocation: $ALLOC_ID)"
                # Check if this is the old EIP we want to keep
                if [ "$EIP_IP" = "3.151.46.11" ]; then
                  echo "Keeping old EIP $EIP_IP for potential reuse"
                else
                  echo "Releasing unused EIP: $EIP_IP"
                  aws ec2 release-address \
                    --region us-east-2 \
                    --allocation-id "$ALLOC_ID" 2>&1 || echo "Failed to release $EIP_IP"
                fi
              fi
            done
          else
            echo "No unused Elastic IPs found"
          fi
        working-directory: terraform
        continue-on-error: true

      - name: Check for existing Elastic IP
        id: check_eip
        run: |
          OLD_EIP="3.151.46.11"
          EIP_EXISTS=$(aws ec2 describe-addresses \
            --region us-east-2 \
            --filters "Name=public-ip,Values=$OLD_EIP" \
            --query 'Addresses[0].AllocationId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$EIP_EXISTS" ] && [ "$EIP_EXISTS" != "None" ] && [ "$EIP_EXISTS" != "" ]; then
            echo "‚úÖ Old Elastic IP $OLD_EIP exists! Allocation ID: $EIP_EXISTS"
            echo "use_existing=true" >> $GITHUB_OUTPUT
            echo "existing_eip=$OLD_EIP" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Old Elastic IP $OLD_EIP does not exist. Using new EIP."
            echo "use_existing=false" >> $GITHUB_OUTPUT
            echo "existing_eip=" >> $GITHUB_OUTPUT
          fi
        working-directory: terraform
        continue-on-error: true

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: terraform
        continue-on-error: false
        env:
          TF_VAR_firebase_credentials: ${{ secrets.FIREBASE_CREDENTIALS }}
          TF_VAR_lambda_whitelist_url: ${{ secrets.LAMBDA_WHITELIST_URL }}
          TF_VAR_use_existing_eip: ${{ steps.check_eip.outputs.use_existing }}
          TF_VAR_existing_eip_address: ${{ steps.check_eip.outputs.existing_eip }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: terraform
        env:
          TF_VAR_firebase_credentials: ${{ secrets.FIREBASE_CREDENTIALS }}
          TF_VAR_lambda_whitelist_url: ${{ secrets.LAMBDA_WHITELIST_URL }}
          TF_VAR_use_existing_eip: ${{ steps.check_eip.outputs.use_existing }}
          TF_VAR_existing_eip_address: ${{ steps.check_eip.outputs.existing_eip }}

      - name: Sync sniproxy config if services.json changed
        if: contains(github.event.head_commit.modified, 'services.json') || contains(github.event.head_commit.added, 'services.json') || github.event_name == 'workflow_dispatch'
        run: |
          echo "Syncing services.json to sniproxy.conf on EC2 instance..."
          
          # Get EC2 instance ID
          INSTANCE_ID=$(aws ec2 describe-instances \
            --region us-east-2 \
            --filters "Name=tag:Name,Values=playmo-smartdns-dns-only-ec2" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
            echo "Found instance: $INSTANCE_ID"
            
            # Get EC2 public IP
            EC2_IP=$(terraform output -raw ec2_public_ip 2>&1 | grep -v "::debug::" | grep -v "Terraform exited" | grep -v "stdout:" | grep -v "stderr:" | grep -v "exitcode:" | tr -d '\n\r' | head -c 50 || echo "")
            
            # Download sync script to instance
            echo "Downloading sync script to EC2..."
            aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=[
                'curl -s -f https://raw.githubusercontent.com/stylz03/playmo-smartdns/main/scripts/sync-sniproxy-config.sh -o /tmp/sync-sniproxy-config.sh',
                'chmod +x /tmp/sync-sniproxy-config.sh',
                'curl -s -f https://raw.githubusercontent.com/stylz03/playmo-smartdns/main/services.json -o /tmp/services.json',
                'EC2_IP=$EC2_IP /tmp/sync-sniproxy-config.sh /tmp/services.json /etc/sniproxy/sniproxy.conf'
              ]" \
              --region us-east-2 \
              --output text > /dev/null 2>&1 || echo "‚ö†Ô∏è SSM command failed, will sync manually via SSH"
            
            echo "‚úÖ sniproxy config sync initiated"
          else
            echo "‚ö†Ô∏è Instance not found, skipping sniproxy sync (will sync on next deployment)"
          fi
        working-directory: terraform
        continue-on-error: true

      - name: Clean up unused EIPs after deployment
        run: |
          echo "Checking for unused Elastic IPs after deployment..."
          # Get current instance's EIP
          INSTANCE_ID=$(aws ec2 describe-instances \
            --region us-east-2 \
            --filters "Name=tag:Name,Values=playmo-smartdns-dns-only-ec2" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
            CURRENT_EIP=$(aws ec2 describe-addresses \
              --region us-east-2 \
              --filters "Name=instance-id,Values=$INSTANCE_ID" \
              --query 'Addresses[0].PublicIp' \
              --output text 2>/dev/null || echo "")
            
            echo "Current instance EIP: $CURRENT_EIP"
            
            # Get all unassociated EIPs (excluding the current one)
            UNUSED_EIPS=$(aws ec2 describe-addresses \
              --region us-east-2 \
              --filters "Name=domain,Values=vpc" \
              --query "Addresses[?AssociationId==\`null\` && PublicIp!=\`$CURRENT_EIP\`].[AllocationId,PublicIp]" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$UNUSED_EIPS" ]; then
              echo "$UNUSED_EIPS" | while read ALLOC_ID EIP_IP; do
                if [ -n "$ALLOC_ID" ] && [ "$ALLOC_ID" != "None" ] && [ -n "$EIP_IP" ]; then
                  echo "Releasing unused EIP: $EIP_IP (Allocation: $ALLOC_ID)"
                  aws ec2 release-address \
                    --region us-east-2 \
                    --allocation-id "$ALLOC_ID" 2>&1 && echo "‚úÖ Released $EIP_IP" || echo "‚ö†Ô∏è Failed to release $EIP_IP"
                fi
              done
            else
              echo "No unused Elastic IPs found"
            fi
          else
            echo "Could not find instance, skipping EIP cleanup"
          fi
        working-directory: terraform
        continue-on-error: true

      - name: Capture Terraform Outputs
        id: tf_outputs
        run: |
          # Capture outputs and clean them (remove debug messages, newlines, and extract only the actual value)
          EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip 2>&1 | grep -v "::debug::" | grep -v "Terraform exited" | grep -v "stdout:" | grep -v "stderr:" | grep -v "exitcode:" | tr -d '\n\r' | head -c 50 || echo "")
          LAMBDA_URL=$(terraform output -raw lambda_function_url 2>&1 | grep -v "::debug::" | grep -v "Terraform exited" | grep -v "stdout:" | grep -v "stderr:" | grep -v "exitcode:" | tr -d '\n\r' | head -c 500 || echo "")
          PROJECT_NAME=$(terraform output -raw project_name 2>&1 | grep -v "::debug::" | grep -v "Terraform exited" | grep -v "stdout:" | grep -v "stderr:" | grep -v "exitcode:" | tr -d '\n\r' | head -c 100 || echo "")
          AWS_REGION=$(terraform output -raw aws_region 2>&1 | grep -v "::debug::" | grep -v "Terraform exited" | grep -v "stdout:" | grep -v "stderr:" | grep -v "exitcode:" | tr -d '\n\r' | head -c 50 || echo "")
          
          # Further clean: extract only IP address pattern for EC2_PUBLIC_IP
          if [[ "$EC2_PUBLIC_IP" =~ ([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) ]]; then
            EC2_PUBLIC_IP="${BASH_REMATCH[1]}"
          fi
          
          echo "Captured EC2_PUBLIC_IP: $EC2_PUBLIC_IP"
          echo "Captured LAMBDA_URL: $LAMBDA_URL"
          echo "Captured PROJECT_NAME: $PROJECT_NAME"
          echo "Captured AWS_REGION: $AWS_REGION"
          
          if [ -n "$EC2_PUBLIC_IP" ] && [[ "$EC2_PUBLIC_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Invalid EC2_PUBLIC_IP: $EC2_PUBLIC_IP"
          fi
          if [ -n "$LAMBDA_URL" ] && [[ "$LAMBDA_URL" =~ ^https?:// ]]; then
            echo "LAMBDA_URL=$LAMBDA_URL" >> $GITHUB_ENV
          fi
          if [ -n "$PROJECT_NAME" ]; then
            echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
          fi
          if [ -n "$AWS_REGION" ]; then
            echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          fi
        working-directory: terraform

      - name: Test Lambda Whitelist
        run: |
          if [ -z "$LAMBDA_URL" ]; then
            echo "‚ö†Ô∏è LAMBDA_URL not set, skipping Lambda test"
            exit 0
          fi
          echo "Testing Lambda function at: $LAMBDA_URL"
          response=$(curl -s -w "\n%{http_code}" -X POST -H "Content-Type: application/json" \
            -d '{"ip":"102.32.16.36","proto":"udp"}' \
            "$LAMBDA_URL" || echo "000")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          echo "Lambda response: $body"
          echo "HTTP status: $http_code"
          if [ "$http_code" != "200" ] && [ "$http_code" != "000" ]; then
            echo "‚ö†Ô∏è Lambda test returned non-200 status, but continuing..."
            exit 0
          fi
        continue-on-error: true

      - name: Test DNS Resolution with Guard
        run: |
          sudo apt-get update && sudo apt-get install -y dnsutils
          
          if [ -z "$EC2_PUBLIC_IP" ] || [[ ! "$EC2_PUBLIC_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ö†Ô∏è EC2_PUBLIC_IP is not set or invalid: '$EC2_PUBLIC_IP'"
            echo "Skipping DNS tests"
            exit 0
          fi
          
          echo "Testing DNS resolution against EC2 instance: $EC2_PUBLIC_IP"
          for domain in netflix.com disneyplus.com youtube.com; do
            echo "Testing $domain against $EC2_PUBLIC_IP..."
            result=$(dig +short $domain @$EC2_PUBLIC_IP 2>&1)
            if [ -z "$result" ] || [[ "$result" == *"Invalid"* ]] || [[ "$result" == *"error"* ]]; then
              echo "‚ùå DNS resolution failed for $domain"
              echo "Result: $result"
            else
              echo "‚úÖ $domain resolved to $result"
            fi
          done
        continue-on-error: true

      - name: Notify Slack on Success
        if: success() && github.event_name != 'schedule'
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"blocks\": [
              {\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"üöÄ SmartDNS Deployment Succeeded\"}},
              {\"type\": \"section\", \"fields\": [
                {\"type\": \"mrkdwn\", \"text\": \"*Project:* $PROJECT_NAME\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Region:* $AWS_REGION\"},
                {\"type\": \"mrkdwn\", \"text\": \"*EC2 IP:* $EC2_PUBLIC_IP\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Lambda URL:* $LAMBDA_URL\"}
              ]},
              {\"type\": \"actions\", \"elements\": [
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"View GitHub Run\"}, \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
              ]}
            ]
          }" \
          ${{ secrets.SLACK_SUCCESS_WEBHOOK }}

      - name: Notify Slack on Failure
        if: failure() && github.event_name != 'schedule'
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"blocks\": [
              {\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"üî• SmartDNS Deployment Failed\"}},
              {\"type\": \"section\", \"fields\": [
                {\"type\": \"mrkdwn\", \"text\": \"*Project:* $PROJECT_NAME\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Region:* $AWS_REGION\"}
              ]},
              {\"type\": \"actions\", \"elements\": [
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"View GitHub Run\"}, \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
              ]}
            ]
          }" \
          ${{ secrets.SLACK_FAILURE_WEBHOOK }}

      - name: Notify Slack Heartbeat
        if: github.event_name == 'schedule'
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"blocks\": [
              {\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"üïí SmartDNS Daily Validation\"}},
              {\"type\": \"section\", \"fields\": [
                {\"type\": \"mrkdwn\", \"text\": \"*Project:* $PROJECT_NAME\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Region:* $AWS_REGION\"},
                {\"type\": \"mrkdwn\", \"text\": \"*EC2 IP:* $EC2_PUBLIC_IP\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Lambda URL:* $LAMBDA_URL\"}
              ]},
              {\"type\": \"actions\", \"elements\": [
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"View GitHub Run\"}, \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
              ]}
            ]
          }" \
          ${{ secrets.SLACK_HEARTBEAT_WEBHOOK }}
